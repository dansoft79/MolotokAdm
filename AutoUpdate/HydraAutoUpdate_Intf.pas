unit HydraAutoUpdate_Intf;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

interface

uses
  {vcl:} Classes, TypInfo,
  {RemObjects:} uROClasses, uROClient, uROTypes, uROClientIntf, uROProxy;

const
  { Library ID }
  LibraryUID = '{A776611C-A47B-4DF1-81A2-A2C900E4D867}';

  { Service Interface ID's }
  IHYAutoUpdateService_IID : TGUID = '{39330BB5-9B50-41B5-AC92-854FC48DD748}';

  { Event ID's }

type
  { Forward declarations }
  IHYAutoUpdateService = interface;

  THYFileUpdateInfoArray = class;
  THYFileSearchInfoArray = class;

  THYFileUpdateInfo = class;
  THYFileSearchInfo = class;


  { Enumerateds }
  THYUpdateOperation = (uoClient,uoAddOrReplace,uoDelete);
  THYUpdateStatus = (usNoUpdates,usNeedsUpdate,usShouldUpdate);
  THYUpdateComparisonMethod = (ucmCompareTime,ucmCompareVersion,ucmUserDefined);
  THYFileUpdateStatus = (fusPending,fusUpdated);

  { THYFileUpdateInfo }
  THYFileUpdateInfo = class(TROComplexType)
  private
    fOperation: THYUpdateOperation;
    fFileName: String;
    fSize: Integer;
    fTimeStamp: DateTime;
    fVersion: String;
    fDownloadProgress: Integer;
    fUserData: String;
    fStatus: THYFileUpdateStatus;
  public
    procedure Assign(iSource: TPersistent); override;
  published
    property Operation:THYUpdateOperation read fOperation write fOperation;
    property FileName:String read fFileName write fFileName;
    property Size:Integer read fSize write fSize;
    property TimeStamp:DateTime read fTimeStamp write fTimeStamp;
    property Version:String read fVersion write fVersion;
    property DownloadProgress:Integer read fDownloadProgress write fDownloadProgress;
    property UserData:String read fUserData write fUserData;
    property Status:THYFileUpdateStatus read fStatus write fStatus;
  end;

  { THYFileUpdateInfoCollection }
  THYFileUpdateInfoCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(Index: integer): THYFileUpdateInfo;
    procedure SetItems(Index: integer; const Value: THYFileUpdateInfo);
  public
    constructor Create; overload;
    function Add: THYFileUpdateInfo; reintroduce;
    procedure SaveToArray(anArray: THYFileUpdateInfoArray);
    procedure LoadFromArray(anArray: THYFileUpdateInfoArray);
    property Items[Index: integer]:THYFileUpdateInfo read GetItems write SetItems; default;
  end;

  { THYFileSearchInfo }
  THYFileSearchInfo = class(TROComplexType)
  private
    fSearchMask: String;
    fRecursive: Boolean;
    fTargetClientDirectory: String;
  public
    procedure Assign(iSource: TPersistent); override;
  published
    property SearchMask:String read fSearchMask write fSearchMask;
    property Recursive:Boolean read fRecursive write fRecursive;
    property TargetClientDirectory:String read fTargetClientDirectory write fTargetClientDirectory;
  end;

  { THYFileSearchInfoCollection }
  THYFileSearchInfoCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(Index: integer): THYFileSearchInfo;
    procedure SetItems(Index: integer; const Value: THYFileSearchInfo);
  public
    constructor Create; overload;
    function Add: THYFileSearchInfo; reintroduce;
    procedure SaveToArray(anArray: THYFileSearchInfoArray);
    procedure LoadFromArray(anArray: THYFileSearchInfoArray);
    property Items[Index: integer]:THYFileSearchInfo read GetItems write SetItems; default;
  end;

  { THYFileUpdateInfoArray }
  THYFileUpdateInfoArray = class(TROArray)
  private
    fCount: Integer;
    fItems : array of THYFileUpdateInfo;
  protected
    procedure Grow; virtual;
    function GetItems(Index: integer): THYFileUpdateInfo;
    procedure SetItems(Index: integer; const Value: THYFileUpdateInfo);
    function GetCount: integer; override;
  public
    class function GetItemType: PTypeInfo; override;
    class function GetItemClass: TClass; override;
    class function GetItemSize: integer; override;
    function GetItemRef(Index: integer): pointer; override;
    procedure SetItemRef(Index: integer; Ref: pointer); override;
    procedure Clear; override;
    procedure Delete(Index: integer); override;
    procedure Resize(ElementCount: integer); override;

    procedure Assign(iSource:TPersistent); override;
    function Add: THYFileUpdateInfo; overload;
    function Add(const Value: THYFileUpdateInfo):integer; overload;

    property Count : integer read GetCount;
    property Items[Index: integer]:THYFileUpdateInfo read GetItems write SetItems; default;
  end;

  { THYFileSearchInfoArray }
  THYFileSearchInfoArray = class(TROArray)
  private
    fCount: Integer;
    fItems : array of THYFileSearchInfo;
  protected
    procedure Grow; virtual;
    function GetItems(Index: integer): THYFileSearchInfo;
    procedure SetItems(Index: integer; const Value: THYFileSearchInfo);
    function GetCount: integer; override;
  public
    class function GetItemType: PTypeInfo; override;
    class function GetItemClass: TClass; override;
    class function GetItemSize: integer; override;
    function GetItemRef(Index: integer): pointer; override;
    procedure SetItemRef(Index: integer; Ref: pointer); override;
    procedure Clear; override;
    procedure Delete(Index: integer); override;
    procedure Resize(ElementCount: integer); override;

    procedure Assign(iSource:TPersistent); override;
    function Add: THYFileSearchInfo; overload;
    function Add(const Value: THYFileSearchInfo):integer; overload;

    property Count : integer read GetCount;
    property Items[Index: integer]:THYFileSearchInfo read GetItems write SetItems; default;
  end;

  { IHYAutoUpdateService }
  IHYAutoUpdateService = interface
    ['{39330BB5-9B50-41B5-AC92-854FC48DD748}']
    function VerifyUpdateStatus(const LastUpdateID: String; out CurrentUpdateID: String; out UserData: String): THYUpdateStatus;
    function GetUpdatesInfo(const UpdateID: String; const ClientFiles: THYFileUpdateInfoArray): THYFileUpdateInfoArray;
    function GetFileData(const UpdateInfo: THYFileUpdateInfo; const Offset: Integer; const Count: Integer; out Data: Binary): Integer;
  end;

  { CoHYAutoUpdateService }
  CoHYAutoUpdateService = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IHYAutoUpdateService;
  end;

  { THYAutoUpdateService_Proxy }
  THYAutoUpdateService_Proxy = class(TROProxy, IHYAutoUpdateService)
  protected
    function __GetInterfaceName:string; override;

    function VerifyUpdateStatus(const LastUpdateID: String; out CurrentUpdateID: String; out UserData: String): THYUpdateStatus;
    function GetUpdatesInfo(const UpdateID: String; const ClientFiles: THYFileUpdateInfoArray): THYFileUpdateInfoArray;
    function GetFileData(const UpdateInfo: THYFileUpdateInfo; const Offset: Integer; const Count: Integer; out Data: Binary): Integer;
  end;

implementation

uses
  {vcl:} SysUtils,
  {RemObjects:} uROEventRepository, uRORes;

{ THYFileUpdateInfoArray }

procedure THYFileUpdateInfoArray.Assign(iSource: TPersistent);
var lSource:THYFileUpdateInfoArray;
    i:integer;
begin
  if (iSource is THYFileUpdateInfoArray) then begin
    lSource := THYFileUpdateInfoArray(iSource);
    Clear();
    Resize(lSource.Count);

    for i := 0 to Count-1 do begin
      if Assigned(lSource.Items[i]) then begin
        Items[i].Assign(lSource.Items[i]);
      end;
    end;
  end
  else begin
    inherited Assign(iSource);
  end;
end;

class function THYFileUpdateInfoArray.GetItemType: PTypeInfo;
begin
  result := TypeInfo(THYFileUpdateInfo);
end;

class function THYFileUpdateInfoArray.GetItemClass: TClass;
begin
  result := THYFileUpdateInfo;
end;

class function THYFileUpdateInfoArray.GetItemSize: integer;
begin
  result := SizeOf(THYFileUpdateInfo);
end;

function THYFileUpdateInfoArray.GetItems(Index: integer): THYFileUpdateInfo;
begin
  if (Index < 0) or (Index >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[Index]);
  result := fItems[Index];
end;

function THYFileUpdateInfoArray.GetItemRef(Index: integer): pointer;
begin
  if (Index < 0) or (Index >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[Index]);
  result := fItems[Index];
end;

procedure THYFileUpdateInfoArray.SetItemRef(Index: integer; Ref: pointer);
begin
  if (Index < 0) or (Index >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[Index]);
  if Ref <> fItems[Index] then begin
    fItems[Index].Free;
    fItems[Index] := Ref;
  end;
end;

procedure THYFileUpdateInfoArray.Clear;
var i: integer;
begin
  for i := 0 to (Count-1) do fItems[i].Free();
  SetLength(fItems, 0);
  FCount := 0;
end;

procedure THYFileUpdateInfoArray.Delete(Index: integer);
var i: integer;
begin
  if (Index>=Count) then RaiseError(err_InvalidIndex, [Index]);

  fItems[Index].Free();

  if (Index<Count-1) then
    for i := Index to Count-2 do fItems[i] := fItems[i+1];

  SetLength(fItems, Count-1);
  Dec(FCount);
end;

procedure THYFileUpdateInfoArray.SetItems(Index: integer; const Value: THYFileUpdateInfo);
begin
  if (Index < 0) or (Index >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[Index]);
  if fItems[Index] <> Value then begin
    fItems[Index].Free;
    fItems[Index] := Value;
  end;
end;

procedure THYFileUpdateInfoArray.Resize(ElementCount: integer);
var i: Integer;
begin
  for i := FCount -1 downto ElementCount do
    FItems[i].Free;
  SetLength(fItems, ElementCount);
  for i := FCount to ElementCount -1 do
    FItems[i] := THYFileUpdateInfo.Create;
  FCount := ElementCount;
end;

function THYFileUpdateInfoArray.GetCount: integer;
begin
  result := FCount;
end;

procedure THYFileUpdateInfoArray.Grow;
var
  Delta, Capacity: Integer;
begin
  Capacity := Length(fItems);
  if Capacity > 64 then
    Delta := Capacity div 4
  else
    if Capacity > 8 then
      Delta := 16
   else
      Delta := 4;
  SetLength(fItems, Capacity + Delta);
end;

function THYFileUpdateInfoArray.Add: THYFileUpdateInfo;
begin
  result := THYFileUpdateInfo.Create;
  Add(Result);
end;

function THYFileUpdateInfoArray.Add(const Value:THYFileUpdateInfo): integer;
begin
  Result := Count;
  if Length(fItems) = Result then
    Grow;
  fItems[result] := Value;
  Inc(fCount);
end;

{ THYFileSearchInfoArray }

procedure THYFileSearchInfoArray.Assign(iSource: TPersistent);
var lSource:THYFileSearchInfoArray;
    i:integer;
begin
  if (iSource is THYFileSearchInfoArray) then begin
    lSource := THYFileSearchInfoArray(iSource);
    Clear();
    Resize(lSource.Count);

    for i := 0 to Count-1 do begin
      if Assigned(lSource.Items[i]) then begin
        Items[i].Assign(lSource.Items[i]);
      end;
    end;
  end
  else begin
    inherited Assign(iSource);
  end;
end;

class function THYFileSearchInfoArray.GetItemType: PTypeInfo;
begin
  result := TypeInfo(THYFileSearchInfo);
end;

class function THYFileSearchInfoArray.GetItemClass: TClass;
begin
  result := THYFileSearchInfo;
end;

class function THYFileSearchInfoArray.GetItemSize: integer;
begin
  result := SizeOf(THYFileSearchInfo);
end;

function THYFileSearchInfoArray.GetItems(Index: integer): THYFileSearchInfo;
begin
  if (Index < 0) or (Index >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[Index]);
  result := fItems[Index];
end;

function THYFileSearchInfoArray.GetItemRef(Index: integer): pointer;
begin
  if (Index < 0) or (Index >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[Index]);
  result := fItems[Index];
end;

procedure THYFileSearchInfoArray.SetItemRef(Index: integer; Ref: pointer);
begin
  if (Index < 0) or (Index >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[Index]);
  if Ref <> fItems[Index] then begin
    fItems[Index].Free;
    fItems[Index] := Ref;
  end;
end;

procedure THYFileSearchInfoArray.Clear;
var i: integer;
begin
  for i := 0 to (Count-1) do fItems[i].Free();
  SetLength(fItems, 0);
  FCount := 0;
end;

procedure THYFileSearchInfoArray.Delete(Index: integer);
var i: integer;
begin
  if (Index>=Count) then RaiseError(err_InvalidIndex, [Index]);

  fItems[Index].Free();

  if (Index<Count-1) then
    for i := Index to Count-2 do fItems[i] := fItems[i+1];

  SetLength(fItems, Count-1);
  Dec(FCount);
end;

procedure THYFileSearchInfoArray.SetItems(Index: integer; const Value: THYFileSearchInfo);
begin
  if (Index < 0) or (Index >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[Index]);
  if FItems[Index] <> Value then begin
    fItems[Index].Free;
    fItems[Index] := Value;
  end;
end;

procedure THYFileSearchInfoArray.Resize(ElementCount: integer);
var i: Integer;
begin
  for i := FCount -1 downto ElementCount do
    FItems[i].Free;
  SetLength(fItems, ElementCount);
  for i := FCount to ElementCount -1 do
    FItems[i] := THYFileSearchInfo.Create;
  FCount := ElementCount;
end;

function THYFileSearchInfoArray.GetCount: integer;
begin
  result := FCount;
end;

procedure THYFileSearchInfoArray.Grow;
var
  Delta, Capacity: Integer;
begin
  Capacity := Length(fItems);
  if Capacity > 64 then
    Delta := Capacity div 4
  else
    if Capacity > 8 then
      Delta := 16
   else
      Delta := 4;
  SetLength(fItems, Capacity + Delta);
end;

function THYFileSearchInfoArray.Add: THYFileSearchInfo;
begin
  result := THYFileSearchInfo.Create;
  Add(Result);
end;

function THYFileSearchInfoArray.Add(const Value:THYFileSearchInfo): integer;
begin
  Result := Count;
  if Length(fItems) = Result then
    Grow;
  fItems[result] := Value;
  Inc(fCount);
end;

{ THYFileUpdateInfo }

procedure THYFileUpdateInfo.Assign(iSource: TPersistent); 
var lSource: HydraAutoUpdate_Intf.THYFileUpdateInfo;
begin
  inherited Assign(iSource);
  if (iSource is HydraAutoUpdate_Intf.THYFileUpdateInfo) then begin
    lSource := HydraAutoUpdate_Intf.THYFileUpdateInfo(iSource);
    Operation := lSource.Operation;
    FileName := lSource.FileName;
    Size := lSource.Size;
    TimeStamp := lSource.TimeStamp;
    Version := lSource.Version;
    DownloadProgress := lSource.DownloadProgress;
    UserData := lSource.UserData;
    Status := lSource.Status;
  end;
end;

{ THYFileUpdateInfoCollection }
constructor THYFileUpdateInfoCollection.Create;
begin
  inherited Create(THYFileUpdateInfo);
end;

constructor THYFileUpdateInfoCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function THYFileUpdateInfoCollection.Add: THYFileUpdateInfo;
begin
  result := THYFileUpdateInfo(inherited Add);
end;

function THYFileUpdateInfoCollection.GetItems(Index: integer): THYFileUpdateInfo;
begin
  result := THYFileUpdateInfo(inherited Items[Index]);
end;

procedure THYFileUpdateInfoCollection.LoadFromArray(anArray: THYFileUpdateInfoArray);
var i : integer;
begin
  Clear;
  for i := 0 to (anArray.Count-1) do
    Add.Assign(anArray[i]);
end;

procedure THYFileUpdateInfoCollection.SaveToArray(anArray: THYFileUpdateInfoArray);
var i : integer;
begin
  anArray.Clear;
  anArray.Resize(Count);
  for i := 0 to (Count-1) do begin
    anArray[i] := THYFileUpdateInfo.Create;
    anArray[i].Assign(Items[i]);
  end;
end;

procedure THYFileUpdateInfoCollection.SetItems(Index: integer; const Value: THYFileUpdateInfo);
begin
  THYFileUpdateInfo(inherited Items[Index]).Assign(Value);
end;

{ THYFileSearchInfo }

procedure THYFileSearchInfo.Assign(iSource: TPersistent); 
var lSource: HydraAutoUpdate_Intf.THYFileSearchInfo;
begin
  inherited Assign(iSource);
  if (iSource is HydraAutoUpdate_Intf.THYFileSearchInfo) then begin
    lSource := HydraAutoUpdate_Intf.THYFileSearchInfo(iSource);
    SearchMask := lSource.SearchMask;
    Recursive := lSource.Recursive;
    TargetClientDirectory := lSource.TargetClientDirectory;
  end;
end;

{ THYFileSearchInfoCollection }
constructor THYFileSearchInfoCollection.Create;
begin
  inherited Create(THYFileSearchInfo);
end;

constructor THYFileSearchInfoCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function THYFileSearchInfoCollection.Add: THYFileSearchInfo;
begin
  result := THYFileSearchInfo(inherited Add);
end;

function THYFileSearchInfoCollection.GetItems(Index: integer): THYFileSearchInfo;
begin
  result := THYFileSearchInfo(inherited Items[Index]);
end;

procedure THYFileSearchInfoCollection.LoadFromArray(anArray: THYFileSearchInfoArray);
var i : integer;
begin
  Clear;
  for i := 0 to (anArray.Count-1) do
    Add.Assign(anArray[i]);
end;

procedure THYFileSearchInfoCollection.SaveToArray(anArray: THYFileSearchInfoArray);
var i : integer;
begin
  anArray.Clear;
  anArray.Resize(Count);
  for i := 0 to (Count-1) do begin
    anArray[i] := THYFileSearchInfo.Create;
    anArray[i].Assign(Items[i]);
  end;
end;

procedure THYFileSearchInfoCollection.SetItems(Index: integer; const Value: THYFileSearchInfo);
begin
  THYFileSearchInfo(inherited Items[Index]).Assign(Value);
end;

{ CoHYAutoUpdateService }

class function CoHYAutoUpdateService.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IHYAutoUpdateService;
begin
  result := THYAutoUpdateService_Proxy.Create(aMessage, aTransportChannel);
end;

{ THYAutoUpdateService_Proxy }

function THYAutoUpdateService_Proxy.__GetInterfaceName:string;
begin
  result := 'HYAutoUpdateService';
end;

function THYAutoUpdateService_Proxy.VerifyUpdateStatus(const LastUpdateID: String; out CurrentUpdateID: String; out UserData: String): THYUpdateStatus;
begin
  try
    __Message.InitializeRequestMessage(__TransportChannel, 'HydraAutoUpdate', __InterfaceName, 'VerifyUpdateStatus');
    __Message.Write('LastUpdateID', TypeInfo(String), LastUpdateID, []);
    __Message.Finalize;

    __TransportChannel.Dispatch(__Message);

    __Message.Read('Result', TypeInfo(HydraAutoUpdate_Intf.THYUpdateStatus), result, []);
    __Message.Read('CurrentUpdateID', TypeInfo(String), CurrentUpdateID, []);
    __Message.Read('UserData', TypeInfo(String), UserData, []);
  finally
    __Message.FreeStream;
  end
end;

function THYAutoUpdateService_Proxy.GetUpdatesInfo(const UpdateID: String; const ClientFiles: THYFileUpdateInfoArray): THYFileUpdateInfoArray;
begin
  try
    result := nil;
    __Message.InitializeRequestMessage(__TransportChannel, 'HydraAutoUpdate', __InterfaceName, 'GetUpdatesInfo');
    __Message.Write('UpdateID', TypeInfo(String), UpdateID, []);
    __Message.Write('ClientFiles', TypeInfo(HydraAutoUpdate_Intf.THYFileUpdateInfoArray), ClientFiles, []);
    __Message.Finalize;

    __TransportChannel.Dispatch(__Message);

    __Message.Read('Result', TypeInfo(HydraAutoUpdate_Intf.THYFileUpdateInfoArray), result, []);
  finally
    __Message.FreeStream;
  end
end;

function THYAutoUpdateService_Proxy.GetFileData(const UpdateInfo: THYFileUpdateInfo; const Offset: Integer; const Count: Integer; out Data: Binary): Integer;
begin
  try
    Data := nil;
    __Message.InitializeRequestMessage(__TransportChannel, 'HydraAutoUpdate', __InterfaceName, 'GetFileData');
    __Message.Write('UpdateInfo', TypeInfo(HydraAutoUpdate_Intf.THYFileUpdateInfo), UpdateInfo, []);
    __Message.Write('Offset', TypeInfo(Integer), Offset, []);
    __Message.Write('Count', TypeInfo(Integer), Count, []);
    __Message.Finalize;

    __TransportChannel.Dispatch(__Message);

    __Message.Read('Result', TypeInfo(Integer), result, []);
    __Message.Read('Data', TypeInfo(Binary), Data, []);
  finally
    __Message.FreeStream;
  end
end;

initialization
  RegisterROClass(THYFileUpdateInfo);
  RegisterROClass(THYFileSearchInfo);
  RegisterROClass(THYFileUpdateInfoArray);
  RegisterROClass(THYFileSearchInfoArray);
  RegisterProxyClass(IHYAutoUpdateService_IID, THYAutoUpdateService_Proxy);


finalization
  UnregisterROClass(THYFileUpdateInfo);
  UnregisterROClass(THYFileSearchInfo);
  UnregisterROClass(THYFileUpdateInfoArray);
  UnregisterROClass(THYFileSearchInfoArray);
  UnregisterProxyClass(IHYAutoUpdateService_IID);

end.